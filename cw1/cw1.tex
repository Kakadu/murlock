%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%  coursework1.tex   %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass{cw1}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}  
\usepackage[russian]{babel}
\usepackage{multirow}
\usepackage{textcomp}
\usepackage{tikz}
\usepackage{graphicx} 
\sloppy                         

\begin{document} \sloppy

\title{Разработка автопрувера на основе секвенциального исчисления с
ослабленными кванторными правилами}

\author{Косарева Дмитрия Сергеевича}
\university{Санкт-Петербургский государственный университет}
\facility{Математико-механический факультет}
\group{341}
\position{студента}
\chair{Кафедра информатики}
\leaderPosition{к.ф.-м.н.}
\leader{А.С. Герасимов}
\city{Санкт-Петербург}
\yr{2010}

\maketitle
\setcounter{page}{2}
\tableofcontents
\newpage

% to economize paper (for printing) uncomment next 5 lines
%\textwidth=190mm
%\textheight=250mm
%\topmargin=-20mm
%\oddsidemargin=-15mm
%\evensidemargin=-15mm

\section{Введение}
\paragraph{}
Для установления факта общезначимсти общезначимых формул используются специальные программы --- автопруверы.
Они могут быть основаны на различных методах, например, на методе семантических таблиц или
на выводе в секвенциальном исчислении.
\paragraph{}
В~\cite{hahnle} предложены кванторные правила вывода с ослабленными ограничениями для
метода семантических таблиц, которые позволяют получить более короткие выводы для некоторых формул.
В~\cite{konev} была проведена адаптация этих правил для секвенциальных исчислений.

\paragraph{}
Целью курсовой работы является
программная реализация автопрувера, использующего правила с ослабленными ограничениями в
секвенциальном исчислении, а также сравнение скорости работы и размера доказательств автопрувера
с автопрувером, использующим классические правила вывода в секвенциальных исчислениях.

\section{Основные определения}
\subsection{Секвенциальное исчисление}
\paragraph{}
Все термины и обозначения, используемые в данной теоритической части работы, и не введенные в ней,
можно найти, например, в~\cite{gerasimov, klini}.

\paragraph{Аксиомы исчисления}
(здесь и ниже: $A$ и $B$ --- любые формулы,  $\Gamma, \Delta$ --- списки любых формул):\\
\begin{center}
  \begin{tabular}{ c }
  $ \Gamma \rightarrow  \Delta, T \! R U \! E$ \\
  $ \Gamma, F\!ALS\!E \rightarrow  \Delta $ \\
  $ \Gamma, A \rightarrow  \Delta, A $ \\
  \end{tabular}
\end{center}

\paragraph{Правила вывода.}
Связки, используемые в автопрувере: $\vee$ --- дизъюнкция, $\&$ --- конъюнкция, $\Rightarrow$ --- импликация,
$\Leftrightarrow$ --- эквивалентность, ! --- отрицание. Ниже указаны правила введения различных связок в
антецедент и сукцедент

\begin{tabular} {  c  c  }
    \begin{tabular}{  c  }
    $ \Gamma, A \rightarrow \Delta  \qquad  \Gamma, B \rightarrow  \Delta$ \\ \hline
    $ \Gamma, A \vee B \rightarrow  \Delta$
    \end{tabular} &
        \begin{tabular}{  c  }
        $ \Gamma \rightarrow  \Delta, A, B$ \\ \hline
        $ \Gamma \rightarrow  \Delta, A \vee B $
        \end{tabular} \\
% конъюнкция
    \begin{tabular}{  c  }
    $ \Gamma, A, B \rightarrow  \Delta$ \\ \hline
    $ \Gamma, A \& B  \rightarrow  \Delta$
    \end{tabular} &
        \begin{tabular}{  c  }
        $ \Gamma \rightarrow \Delta, A  \qquad  \Gamma \rightarrow  \Delta, B$ \\ \hline
        $ \Gamma \rightarrow  \Delta, A \& B $
        \end{tabular} \\
% импликация
    \begin{tabular}{  c  }
    $ \Gamma \rightarrow \Delta, A  \qquad  \Gamma, B \rightarrow  \Delta$ \\ \hline
    $ \Gamma,  \Rightarrow B \rightarrow  \Delta$
    \end{tabular} &
        \begin{tabular}{  c  }
        $ \Gamma, A \rightarrow  \Delta, B$ \\ \hline
        $ \Gamma \rightarrow  \Delta, A \Rightarrow B$
        \end{tabular} \\
% эквивалентность
    \begin{tabular}{  c  }
    $ \Gamma, A, B \rightarrow \Delta  \qquad  \Gamma \rightarrow  \Delta, A, B$ \\ \hline
    $ \Gamma, A \Leftrightarrow B \rightarrow  \Delta$
    \end{tabular} &
        \begin{tabular}{  c  }
        $ \Gamma, A \rightarrow  \Delta, B \qquad \Gamma, A \rightarrow \Delta, B$ \\ \hline
        $ \Gamma \rightarrow  \Delta, A \Leftrightarrow B$
        \end{tabular} \\
% отрицание
    \begin{tabular}{  c  }
    $ \Gamma, !A \rightarrow \Delta  $ \\ \hline
    $ \Gamma \rightarrow  \Delta, A$
    \end{tabular} &
        \begin{tabular}{  c  }
        $ \Gamma \rightarrow  \Delta, !A $ \\ \hline
        $ \Gamma, A \rightarrow  \Delta$
        \end{tabular} 

\end{tabular}\\

\paragraph{}
Кванторные минус-правила ($A$ --- любая формула; $x$ --- любая предметная переменная;
$t$ --- любой терм, свободный для подстановки вместо $x$ в  $A$):
\begin{center}
    \begin{tabular} {  c  c  }
      \begin{tabular}{  c  }
      $ \Gamma, \forall x A, [A]_{t}^{x} \rightarrow  \Delta$ \\ \hline
      $ \Gamma, \forall x A \rightarrow  \Delta$
      \end{tabular} &
        \begin{tabular}{  c  }
        $ \Gamma \rightarrow  \Delta, \exists x A, [A]_{t}^{x}$ \\ \hline
        $ \Gamma \rightarrow \Delta, \exists x A$
        \end{tabular} \\
    \end{tabular}
\end{center}

Кванторные плюс-правила ($A$ --- любая формула; $x$ --- любая предметная переменная;
$y$ --- любая предметная переменная, свободная для подстановки вместо $x$ в  $A$
и не входящая свободно в заключение правила):
\begin{center}
    \begin{tabular}{c c}
        \begin{tabular}{  c  }
        $ \Gamma, [A]_{y}^{x} \rightarrow  \Delta$ \\ \hline
        $ \Gamma, \exists x A \rightarrow  \Delta$
        \end{tabular} &
            \begin{tabular}{  c  }
            $ \Gamma \rightarrow  \Delta, [A]_{y}^{x}$ \\ \hline
            $ \Gamma \rightarrow \Delta, \forall x A$
            \end{tabular} \\
        \end{tabular}
\end{center}

\subsection{Поиск вывода в секвенциальном исчислении с метапеременными}
\label{sec:build_tree}
\paragraph{}
Исчисление предикатов в общем случае алгоритмически не разрешимо, поэтому автопрувер,
реализованный в рамках данной курсововй работы,
заканчивает работу с одним из двух результатов: ``доказано'' или ``неизвестно''.

%Процесс получения одного из этих результатов для исходной секвенции будем
%называть анализом данной секвенции.
\paragraph{}
При поиcке вывода секвенции происходит построение дерева поиска вывода этой секвенции. В узлах и
листьях дерева находятся секвенции; секвенции в листьях дерева будем называть листовыми
секвенциями. Рост дерева осуществляется путём контрприменения правил вывода, указанных выше, к
листовым
секвенциям. Если все листовые секвенции являются аксиомами, то исходная секвенция является
доказанной и поиск вывода завершается.
\paragraph{}
Приведенный выше процесс построения дерева поиска вывода не является абсолютно точным (подробнее
об этом можно прочитать, например, в~\cite{gerasimov}). В частности, является существенным порядок, в котором
мы будем выбирать формулы, к которым будет осуществляться контрприменение правила. Рассмотрим
секвенцию $\rightarrow A \vee !A, \exists x P$. Осуществив контрприменение правил $\rightarrow \vee$ и
$\rightarrow !$, можно получить вывод, но его не удастся получить, если осуществлять
только контрприменение правила $\rightarrow \exists$.
Поэтому, необходимо, чтобы контрприменение правил вывода осуществлялось ко всем
формулам секвенции равномерно, что вызывает некоторые сложности в реализации автопрувера.

\paragraph{}
Зачастую, приведенный выше метод поиска вывода используется в совокупности с методом метапеременных.
Суть метода метапеременных заключается
в том, что мы откладываем подбор терма при осуществлении контрприменения минус-правил
и используем вместо него метапеременную. Затем мы в некоторый момент времени
приостанавливаем доказательство и запускаем процедуру подбора подстановки термов для метапеременных,
называемую унификацией. Если унификация прошла успешно, т.е. после осуществления подстановки
некоторых термов вместо метапеременных все листовые секвенции стали аксиомами, то формула
успешно доказана. Иначе следует продолжить построение дерева путём осуществления контрприменения
правил вывода к листовым секвенциям и, возможно, на новом наборе листовых секвенций унификация
пройдет успешно. 
\paragraph{}
Процедура унификации ниже будет пониматься в разных смыслах: унификация пары термов --- поиск
подстановки, после осуществления который термы станут одинаковыми. Унификация списка пар термов
 --- поиск подстановки, после осуществления которой все пары списка станут одинаковыми.
 \paragraph{}
Унификация пары атомарных формул (в случае когда предикатные символы одинаковые и
количество аргументов тоже) сводится к унификации списка пар термов --- пар соответствующих
аргументов.
\paragraph{}
Унификация секвенций будет подробно рассматриваться в разделе~\ref{sec:unif_seq_list}, а унификация
пар термoв --- в разделе~\ref{sec:unif_pairs_list}.

\subsection{Кванторные правила вывода с ослабленными ограничениями}
\label{sec:librules}
Плюс-правила, указанные в~\cite{hahnle} и приведенные ниже, обеспечивают более короткое доказательство для
некоторых формул, по сравнению с обычными плюс-правилами.
\begin{center}
  \begin{tabular}{c c}
      \begin{tabular}{  c  }
      $ \Gamma, [A]_{y}^{x} \rightarrow  \Delta$ \\ \hline
      $ \Gamma, \exists x A  \rightarrow  \Delta$
      \end{tabular} &
          \begin{tabular}{  c  }
          $ \Gamma \rightarrow  \Delta, [A]_{y}^{x} $ \\ \hline
          $ \Gamma \rightarrow \Delta, \forall x A$
          \end{tabular}
  \end{tabular}
\end{center}
Здесь $A$ --- любая формула, $x$ --- любая предметная переменная, $y$ --- новая предметная
переменная. При осуществлении контрприменения этих правил для всех метапеременных $\xi$
и для всех предметных переменных $w$ добавляются новые ограничения вида $y \succ \xi, y \succ w$.
Чтобы проверить, удовлетворяет и подстановка $\sigma$ множеству ограничений, мы сначала
для каждой замены в $\sigma$ вида $\xi \mapsto t$ (где $\xi$ --- это метапеременная, а $t$ --- терм),
добавляем в множество ограничений  ограничения вида $\xi \succ w$ и $\xi \succ \zeta$
для каждой предметной переменной $ w $ и для каждой метапеременной $\zeta$, входящих в $ t $. Затем мы проверяем,
что отношение $\succ$ не имеет циклов.

% \paragraph{}
% В приложениях приведены примеры деревьев вывода формулы $\exists x ((\forall z P(z)) \vee !P(x))$
% при использовании классических правил и правил с ослабленными ограничениями.
% Во втором случае дерево вывода получается в 2 раза короче.\\

\paragraph{}
Ниже пример вывода секвенции  $\rightarrow \exists x (\forall z P(z) \vee !P(x))$ в исчислении с обычными
кванторными правилами (каждая секвенция, кроме последней, получается из следующей по соответствующему
правилу)

\begin{enumerate}
 \item $ \rightarrow \exists x (\forall z P(z) \vee !P(x)) \qquad (\rightarrow \exists)$
 \item $ \rightarrow (\forall z P(z)) \vee !P(\xi), \exists x (\forall z P(z) \vee !P(x))  \qquad (\rightarrow \vee)$\\
 Выбирается новая метапеременная $\xi$
 \item $ \rightarrow (\forall z P(z)), !P(\xi), \exists x (\forall z P(z) \vee !P(x))  \qquad (\rightarrow !)$
 \item $P(\xi) \rightarrow \forall z P(z), \exists x (\forall z P(z) \vee !P(x))  \qquad (\rightarrow \forall)$
 \item $P(\xi) \rightarrow P(w), \exists x (\forall z P(z) \vee !P(x))  \qquad (\rightarrow \exists)$\\
 Выбирается новая предметная переменная $w$; добавляeтся ограничениe $\xi \succ w$;
 невозможно провести успешную унификацию данной секвенции.
 \item $P(\xi) \rightarrow P(w), \forall z P(z) \vee !P(\chi), \exists x (\forall z P(z) \vee !P(x))  \qquad (\rightarrow \vee)$\\
 Выбирается новая метапеременная $\chi$
 \item $P(\xi) \rightarrow P(w), \forall z P(z), !P(\chi), \exists x (\forall z P(z) \vee !P(x))  \qquad (\rightarrow !)$
 \item $P(\xi), P(\chi) \rightarrow P(w), \forall z P(z), \exists x (\forall z P(z) \vee !P(x)) \qquad (\rightarrow \forall)$
 \item $P(\xi), P(\chi) \rightarrow P(w), P(v), \exists x (\forall z P(z) \vee !P(x))$ \\
 Выбирается новая предметная переменная $v$; добавляeтся ограничениe $\xi \succ v$ и $\chi \succ v$;
 унифицирующая подстановка $\chi \mapsto w $.\\
\end{enumerate}

Ниже пример вывода секвенции  $\rightarrow \exists x ((\forall z P(z)) \vee !P(x))$ в исчислении с ослабленными
кванторными правилами(каждая секвенция, кроме последней, получается из следующей по соответствующему
правилу)
\begin{enumerate}
 \item $ \rightarrow \exists x ((\forall z P(z)) \vee !P(x)) \qquad (\rightarrow \exists)$
 \item $ \rightarrow (\forall z P(z)) \vee !P(\xi), \exists x ((\forall z P(z)) \vee !P(x))  \qquad (\rightarrow \vee)$\\
 Выбирается новая метапеременная $\xi$
 \item $ \rightarrow (\forall z P(z)), !P(\xi), \exists x ((\forall z P(z)) \vee !P(x))  \qquad (\rightarrow !)$
 \item $P(\xi) \rightarrow \forall z P(z), \exists x ((\forall z P(z)) \vee !P(x))  \qquad (\rightarrow \forall)$
 \item $P(\xi) \rightarrow P(w), \exists x ((\forall z P(z)) \vee !P(x))  \qquad (\rightarrow \exists)$\\
 Выбирается новая предметная переменная $w$ и не добавляется никаких ограничений.
 Унифицирующая подстановка: $\xi \mapsto w$
\end{enumerate}
\paragraph{}
В случае правил с ослабленными ограничениями вывод получился значительно короче.


\section{Реализация автопрувера}
В данном разделе мы будет говорить о конкретном автопрувере, реализованном в рамках данной
курсовой работы.
В качестве языка реализации был выбран OCaml из моих личных предпочтений.
Ознакомиться с языком можно с помощью~\cite{OCamlManual} (также можно найти неофициальный
перевод на русский язык). Познакомиться с терминами, свойственными функциональному програмированию
 можно с помощью~\cite{FuncDT}.
%Возможно, что особое внимание в~\cite{FuncDT} стоит уделить разделам:
% \begin{description}
%  \item[чисто функциональная структура данных (раздел 3)]  ---
%   этот термин будет встречаться при обосновании выбора момента для проверки ограничений
%   для ослабленных правил;
%   \item [функция высшего порядка (раздел 8),] 
%    так как понятие о таких функциях желательно для обоснования
% наличия параметров-функций, например, в функции $proveAbstr$;
%   \item [свёртка (раздел 11)] ---
%   функция  $unif\_pairs\_list$ по сути является свёрткой.
%  \end{description}

\subsection{Представление секвенции в программе}
\label{sec:sequences}
\paragraph{}
В автопрувере присутствуют два типа, представляющих секвенцию --- это $Proprules.sequence$ и
$BigSeq.bigSeq$\footnote{Здесь используется метод именования типов, используемая в языке $OCaml$.
Запись $Proprules.sequence$ означает, что в модуле $Proprules$ описан тип $sequence$.}.
Первый используется для легковесного представления секвенции: все формулы
антецедента и сукцедента. Второй используется только в процессе построения дерева поиска вывода
и содержит в себе дополнительную информацию о количестве осуществленных контрприменений
минус-правил вывода к формулам. 
\paragraph{}
Формулы, принадлежащие секвенции типа $bigSeq$, разделены на пять видов: атомарные, формулы для
однопосылочных правил, формулы для двупосылочных правил, формулы для минус-правил и формулы                                                             
для плюс-правил. Благодаря такому представлению функция контрприменения
правил к секвенции выглядит так: сначала пытаемся осуществить контрприменение правил одного
вида, затем второго и т.д.
\paragraph{}
Для обеспечения того, что к формулам осуществляется контрприменение минус-правил
равномерно, в типе $bigSeq$ с каждой формулой, к которой можно осуществить контрприменение
минус-правила, ассоциировано
количество доступных контрприменений. При осуществлении контрприменения правил эти количества наследуются потомкам.
\paragraph{}
Изначально с каждой формулой, к которой можно осуществить контрприменение минус-правила,
ассоциирована 1. После осуществления
контрприменения, с этой формулой ассоциирован 0. Если осуществить, контрприменение
правила к этой формуле ещё раз, то по причине того, что с этой формулой ассоциирован 0,
осуществить контрприменение правила к этой формуле будет невозможно.
\paragraph{}
Итак, если к секвенции, представленной типом $bigSeq$ невозможно осуществить контрприменение
минус-правила, то это означает, что либо подхоящих формул нет, либо с каждой такой формулой
ассоциирован 0. Если ко всем листовым секвенциям дерева поиска вывода не применимо ни
одно правило вывода, то проводим \textit{унификацию по распорядку}. Она
вызывается в функции $proveAbstr$ из раздела~\ref{sec:proveAbstr}.      
\paragraph{}
Ниже приведены несколько функций, с помощью которых осуществляется работа с типом $bigSeq$.\\
\qquad \\
\textbf{Функция} $can\!ApplyRules(seq)$\\
\textbf{Вход:} $seq$ --- секвенция.\\
\textbf{Выход:} TRUE, если можно осуществить контрприменения хотя бы одного правила вывода. FALSE
иначе.\\
\textbf{Метод:} Если есть формулы, подходящие для осуществления контрприменения однопосылочных,
двупосылочных, плюс-правил, то TRUE. Если есть формула для осуществления контрприменения
минус-правила, и с ней ассоциирована 1, то тоже TRUE. Иначе FALSE.\\
\qquad \\
\textbf{Функция} $apply\!Rule(seq, minusT\!erm, plusT\!erm)$\\
\textbf{Вход:} $seq$ --- cеквенция, к которой осуществляется контрприменение; $minusTerm$ --- функция подбора нового терма
для минус-правил, $plusTerm$ --- функция подбора нового терма для плюс-правил.\\
\textbf{Выход:} Пара, которая состоит из списка секвенций-посылок и правила вывода,
которое было контрприменено. Либо NULL, если не удалось осуществить контрприменение
ни одного правила.\\
\qquad \\
\textbf{Функция} $re\!f\!reshCounters(seq)$\\
\textbf{Вход:} $seq$ --- cеквенция.\\
\textbf{Метод:} Ассоциировать с каждой формулой, подходящей под минус-правило, 1.

\paragraph{}
Важно подчеркнуть, что осуществление контрприменения правил реализовано в типе $bigSeq$, а
функция построения дерева поиска вывода $proveAbstr$ из раздела~\ref{sec:proveAbstr} для получения новых секвенций
из листовых вызывает, только что описанную, функцию $applyRule$. Также функция $proveAbstr$ в нужный
момент вызывает функцию $refreshCounters$ для продолжения построения дерева.

\subsection{Унификация}
\subsubsection{Представление ограничений и подстановок в программе}
\label{sec:subs_and_forbs}
\textit{Подстановка} --- это конечный набор упорядоченных пар, в каждой из которых первым элементом пары является
метапеременная, а вторым --- некоторый терм\footnote{В автопрувере метапеременные были включены в
язык как терм наравне с предметными переменными,
предметными константами и функциональными символами}, причем не существует двух пар, где первым
элементом является одна и таже метапеременная.
\paragraph{}
Это определение дает ясное представление  том, как надо хранить подстановку в программе; например,
как список пар, где первым элементом является метапеременная, а вторым --- некоторый терм\footnote{Если более детально углубиться в реализацию автопрувера, подстановка не является списком пар,
а реализована с помощью функтора $Map.Make$, что обеспечивает более эффективную выборку по
метапеременной сопоставленного ей терма. Реальное преимущество по скорости работы в
написанном автопрувере за счет использования функтора невелико, так как деревья вывода
сравнительно небольшие и количество метапеременных в подстановке невелико. Подробнее о функторах
можно прочитать в \cite{OCamlManual}, но если говорить коротко о конкретном функторе $Map.Make$,
то это аналог $Dictionary$ в языке $C\#$ и $Map$ в платформе $Java$.}.

\paragraph{}
Отметим здесь, что ниже под носителем подстановки будет пониматься множество первых элементов пар.
Носитель подстановки $\theta$ будет обозначаться $Dom(\theta)$.
Под $\theta(\xi)$ (где $\theta$ --- это любая подстановка, а $\xi$ --- любая метапеременная из
$Dom(\theta)$) будет
пониматься терм, поставленный в соответствие метапеременной $\xi$ (т.е. второй элемент
пары $(\xi,t)$).
\paragraph{}
Подстановка \textit{без циклов} --- это такая подстановка, что
$$
\forall\xi\in Dom(\theta) (metavars(\theta(\xi))\cap Dom(\theta)=\emptyset)
$$
где
$metavars(t)$ -- это множество всех метапеременных, которые входят свободно в терм $t$. Только такие подстановки
будут получаться при успешном окончании работы функции унификации списка пар термов, которая
будет рассмотрена в разделе \ref{sec:unif_pairs_list}.
\paragraph{}
Определения ограничений на подстановку будут даваться по аналогии c определением
подстановки, отдельно для исчислений с обычными правилами и с ослабленными.
\paragraph{}
\textit{Ограничения на подстановку (для обычных правил)} --- это конечный набор пар, в каждой из
которых первым элементом пары является метапеременная, а правым --- множество предметных переменных,
причем не существует двух пар, где первым элементом является одна и таже метапеременная.
$Dom(\phi)$ (где $\phi$ --- это ограничения) вводится аналогично определению подстановки.
\paragraph{}
Ограничения добавляются в момент осуществления контрприменения плюс-правил и выборе новой
предметной переменной $w$. То, что $w$ является новой предметной переменной, означает, что она
не входит свободно в данную секвенцию, т.е. не входит свободно в формулы данной секвенции, а также не
входит свободно во все термы, которые будут поставлены в соответствие всем метапеременным,
встречающимся в данной секвенции. Таким образом момент в выбора новой предметной переменной
$w$ из данной секвенции выбираются все метапеременные и к правой части соответствующих им пар
добавляется эта предметная переменная $w$. Если пары, соответствующей метапеременной $\xi$ нет,
то к ограничениям добавляется новая пара $(\xi,\{w\})$.
\paragraph{}
Итак, пару $(\xi,R)$ стоит понимать так: ни одна предметная перменная из
$R$ не входит свободно в терм, поставленный в соответствие метапеременной $\xi$ при осуществлении
подстановки в секвенциальном исчислении с обычными правилами.
\paragraph{}
\textit{Ограничения на подстановку (для ослабленных правил)} --- это конечный набор пар, в каждой из
которых первым элементом пары является метапеременная или предметная переменная, а правым ---
множество  метапеременных или предметных переменных,
причем не существует двух пар, где первым элементом является одна и таже метапеременная или предметная
переменная. $Dom(\phi)$ вводится аналогично.
\paragraph{}
О том, как эти ограничения образуются, было сказано в разделе \ref{sec:librules}.
\paragraph{}
Ниже представлено несколько функций, используемых для проверки ограничений. Они вызываются
при проведении унификации с помощью функции $unif\!\_pairs\_list$ из раздела~\ref{sec:unif_pairs_list}.
\\\qquad \\
\textbf{Функция: } $checkRestrictionsN\!ormal$\\
\textbf{Вход: } $\theta$ --- подстановка; $\phi$ --- ограничения, наложенные обычными правилами
вывода.\\
\textbf{Выход:} TRUE, если $\theta$ удовлетворяет ограничениям, наложенным обычными правилами вывода.
Иначе --- FALSE.\\
 \textbf{Метод:}
 \begin{enumerate}
  \item Для каждой пары $(\xi,t)$ из $\theta$ выбираем пару $(\xi,R)$ из $\phi$. Если в $\phi$ такой пары
  нет, то считаем, что $R$ --- это пустое множество.
  Создаем $R'$ --- мнодество всех предметных переменных, входящих в терм $t$. Если множества
  $R$ и $R'$ пересекаются, то завершаем работу с результатом FALSE. Если $\xi$ входит свободно в $t$,
  то также возвращаем FALSE.
  \item Возвращаем TRUE.
 \end{enumerate}
Эта функция будет работать правильно, если подстановка без циклов. Именно такие подстановки
и будут получаться при работе функции $unif\_pairs\_list$ из раздела \ref{sec:unif_pairs_list}.\\
 \qquad \\
\textbf{Функция: } $check\!RestrictionsLiberalised$\\
\textbf{Вход: } $\theta$ --- подстановка; $\phi$ --- ограничения, наложенные ослабленными правилами
вывода.\\
\textbf{Выход:} TRUE, если $\theta$ удовлетворяет ограничениям $\phi$, наложенным ослабленными
правилами вывода. Иначе --- FALSE.\\
\textbf{Метод:}
\begin{itemize}
 \item Создаем пустой граф. Выберем все предметные переменные и метапеременные, которые встречаются
 в $Dom(\theta)$ и $Dom(\phi)$. Для каждой их этих предметных переменных и
 метапеременных создадим вершину в графе.
 \item Для всех  $k \in Dom(\phi)$  выполняем следующее:
 выбираем вершину $K$, соответствующую $k$;
 для каждой предметной переменной и метапеременной $x$ из $\phi(k)$ выбираем соответствующую
 ей вершину графа $V$; проводим ребро от $K$ до $V$.
 \item Для всех $k \in Dom(\theta)$ выполняем следующее:
 выбираем вершину $K$, соответствующую  $k$;
 для каждой предметной переменной, входящей в терм $\theta(k)$, выбираем соответствующую
 ей вершину графа $V$; проводим ребро от $K$ до $V$.
\item Если полученный граф не содержит циклов, то возвращаем TRUE. Иначе --- FALSE.
\end{itemize}

Далее представлены функции для получения нового терма для исчисления с обычными правилами вывода
и с ослабленными. 
\begin{description}
 \item[Подбор нового терма для минус правила] \qquad \\
    \textbf{Функция}: $getMinusTerm(seq,fip)$\\
    \textbf{Вход: }  $seq$ --- секвенция, к которой осуществляется контрприменения минус-правила;
    $fip$ --- формула, к которой осуществляется контрприменение минус-правила.\\
    \textbf{Выход:} Новая метапеременная.\\
    \textbf{Метод:}
    \begin{itemize}
    \item В глобальном счетчике хранится номер последней введенной метапеременной.
    \item В случае вызова функции счетчик инкрементируется и возвращается новая метапеременная
    с именем из строки $\_\_m$ и значением счетчика.
    \end{itemize}
  \item[Подбор нового терма для обычных плюс-правил] \qquad \\
    \textbf{Функция:} $getPlusTerm(seq,fip)$\\
    \textbf{Вход: }  $seq$ --- секвенция, к которой осуществляется контрприменения плюс-правила;
    $fip$ --- формула, к которой осуществляется контрприменение плюс-правила.\\
    \textbf{Выход:} Новая предметная переменная.\\
    \textbf{Метод:}
    \begin{itemize}
    \item Глобально хранится номер последней введенной предметной переменной в счетчике.
    \item В случае вызова функции счетчик инкрементируется и возвращается новая предметная
    переменная с именем, состоящем из буквы $w$ и значения счетчика, например $w5$.
    \item Для всех метапеременных $\xi$ из секвенции $seq$ добавляются новые ограничения $\xi \succ w5$.
    (куда дбавляются, нписать как хранятся ограничения)
    \end{itemize}
  \item [Подбор нового терма для ослабленных плюс-правил]\quad\\
    \textbf{Функция}: $getPlusTerm(seq,fip)$\\
    \textbf{Вход: }  $seq$ --- секвенция, к которой осуществляется контрприменения плюс-правила;
    $fip$ --- формула, к которой осуществляется контрприменение плюс-правила.\\
    \textbf{Выход:} Новая предметная переменная.\\
    \textbf{Метод:}
    \begin{itemize}
    \item Глобально хранится номер последней введенной предметной переменной в счетчике.
    \item В случае вызова функции счетчик инкрементируется и возвращается новая предметная
    предметная переменная с именем, состоящем из $w$ и значения счетчика, например $w5$.
    \item Для всех метапеременных $\xi$ и предметных переменных $v$ из $fip$, входящих в формулу, добавляем
    ограничения $w5 \succ \xi$ и $w5 \succ v$.
    \end{itemize}
 \end{description}

\paragraph{}
Стоит заметить, что функция получения метапеременной никак не использует аргументы $seq$ и $fip$,
функция подбора нового терма для обычных правил не использует аргумента $fip$,
функция подбора нового терма для ослабленных правил не использует аргумента $seq$. Так сделано для обеспечения
гибкости реализации автопрувера: если понадобится реализовать исчисление, в котором необходимо будет добавлять
ограничения в момент подбора новой метапеременной, то это можно будет делать без особых проблем.
Также функция построения дерева поиска вывода $proveAbstr$ (приведенная ниже) принимает функции получения новых
термов для плюс- и минус-правил как аргументы; благодаря этому, вызывая её с различными функциями (для
обычных правил и для ослабленных), можно  получать доказательства в одном и другом исчислении.

\subsubsection{Унификация набора секвенций}
\label{sec:unif_seq_list}
\paragraph{}
Чтобы провести унификацию одной секвенции необходимо выбрать всеми возможными способоми пару формул:
одну из антецедента, другую --- из сукцедента. Если хотя бы для одной пары формул можно подобрать
(c помощью функции  $unif\!\!\_pairs\!\_list$, рассматриваемой в разделе~\ref{sec:unif_pairs_list})
подстановку, удовлетворяющую ограничениям и унифицирующую эту пару формул, то секвенция унифицируема
с помощью этой подстановки (о том как провести унификацию пары формул уже кратко говорилось в
конце раздела~\ref{sec:build_tree}). Если ни для одной пары формул не удалось получить унифицирующущю подстановку,
удовлетворяющую ограничениям, то провести успешную унификацию данной секвенции невозможно.
\paragraph{}
Пусть есть список из $n$ секвенций. \textit{Целью унификации} будем называть список из $n$ пар атомарных
формул, такой что:
\begin{itemize}
 \item пара, соответствующая секвенции, состоит из двух формул: одна из антецедента, другая
 из сукцедента.
 \item $i$-я пара взята из $i$-ой секвенции списка.
\end{itemize}
\paragraph{}
Чтобы провести унификацию набора секвенций, необходимо подобрать такую цель
унификации, для которой функция $unif\!\!\_pairs\!\_list$ вернет некоторую подстановку, а не NULL. Поиск осуществляется
полным перебором всевозможных целей унификации.
\paragraph{}
Подстановка $\Theta$ унифицирует набор секвенций, если после осуществления подстановки $\Theta$ во все
формулы всего набора секвенций все секвенции становятся аксиомами.

\paragraph{Методы сокращения перебора.}
\textit{Метод №1.} Если в цель унификации входит пара, которая не унифицируема (с помощью функции
$unif\_pairs\_list$) отдельно от всей цели, то вся цель унификации не унифицируема. Поэтому цели
унификации с неунифицируемыми парами формул не нужно унифицировать (не нужно передавать
на вход функции $unif\_pairs\_list$, искомую подстановку мы гарантированно не получим).
\paragraph{}
\textit{Метод №2.}
Если из некоторой секвенции можно получить только одну успешно унифицируемую пару формул, то
унификацию этой пары можно провести немедленно, получив некоторую подстановку $\theta$, которая
будет входить в подстановку $\Theta$, где $\Theta$ существует и является подстановкой,
которая унифицирует хотя бы одну цель унификации, т.е. является искомой подстановкой.
\paragraph{}
Если при использовании метода №2 было получено несколько ``маленьких'' подстановок, то их можно
объединить с помощью композиции. Если подстановки противоречат друг другу (переводят одни
и те же метапеременные в различные термы), то провести композицию невозможно (подстановки
несовместны), и весь
набор секвенций объявляется неунифицируемым без осуществления перебора.
  После осуществления композиции некоторые пары формул могут стать неунифицируемыми по причине того,
что унифицирующая их подстановка несовместна с уже полученной. 
\paragraph{}
Комбинируя два, указанных выше, метода можно значительно (для большого числа листовых секвенций
--- на порядки) сократить количество пар формул, т.е. объем перебора. Для использования данных методов,
необходимо сгенерировать пары термов заранее.
Без этого можно было бы обойтись, используя курсоры, но в этом случае приведенные выше методы
сокращения перебора не работают.
\paragraph{}
Когда возможности по сокращению перебора исчерпали себя, необходимо переходить к перебору всех
целей унификации.

\paragraph{Осуществление перебора пар термов.}
Если мы сможем занумеровать все цели унификации (которых конечное число) натуральными числами,
то их можно легко перебрать. Сейчас мы приведем один из способов нумерации.
\paragraph{}
Предположим, что дано $n$ секвенций, из каждой секвенции выбрано $m_k$ пар ($k=1..n$) и они были
переданы для осуществления перебора.
Будем использовать $n$-разрядное число в позиционной системе исчисления. Разряды будем нумеровать
от 1 до $n$, в $k$-ом разряде будет использоваться $m_k$-ичная система исчисления.
\paragraph{}
Пусть дано число в такой системе исчисления. Выберем из $1$-й секвенции пару под номером, стоящем
в $1$-м разряде данного числа, из $2$-й секвенции пару под номером, стоящем
в $2$-м разряде данного числа, и т.д. до $n$-го разряда. Полученный набор и $n$ пар будет целью
унификации, соответствующей данному числу. Таким образом мы установили взаимооднозначное соответствие
между числами в указанной позиционной системе исчисления и целями унификации.
\paragraph{}
Начав перебор с нуля в данной системе исчисления и постепенно прибавляя по 1 можно перебрать все
числа, а значит и все цели унификации.

\paragraph{Ещё один метод сокращения перебора.}
Предположим, что мы выбрали некоторое число, по нескольким старшим разрядам выбрали пары термов,
и не смогли получить унифицирующую подстановку для этих пар. Очевидно, что какие бы ни были младшие
разряды, унифицирующую подстановку для целей унификации, содержащих пары для старших
разрядов получить
невозможно. Следовательно, некоторые цели унификации можно пропустить, прибавив не 1, а некоторое
другое число.
\paragraph{}
Итак, в этой части мы рассмотрели как проводить унификацию секвенций, также методы
сокращения перебора: первые два метода сокращают количество пар, из которых будут строиться
цели унификации; последний сокращает собственно количество целей унификации. 

\subsubsection{Унификация пар термов}
\label{sec:unif_pairs_list}
Здесь мы будем говорить об основной функции для осуществления унификации --- функции
$unif\!\_pairs\!\_list$.
\\ \quad \\
\textbf{Функция:} $unif\!\_pairs\!\_list(lst,\theta,\phi)$\\
\textbf{Вход: } $lst$ --- список пар термов; $\theta$ --- подстановка; $\phi$ --- ограничения на подстановку
при обычных правилах вывода.\\
\textbf{Выход:} Подстановка или NULL, если термы неунифицируемы.\\
\textbf{Метод:}
\begin{enumerate}
 \item Рассматриваем головной элемент списка. Если это пара функциональных символов, у которых одинаковые
 имена и одинаковое количество аргументов, то добавляем новые пары термов к хвостам исходных списков и
 запускаем функцию  рекурсивно для новых списков, текущей подстановки $\theta$ и тех же ограничений $\phi$. Если имена различны или
 различно количество аргументов, то унификацию провести невозможно --- возвращаем NULL.
 \item Пусть в голове списка стоят два терма. Если первый терм является метапеременной
 $\xi \in Dom(\theta)$, то мы будем проводить унификацию пары, где первым элементом стоит $\theta(\xi)$.
 Аналогично поступим и со вторым термом. Затем запустим унификацию рекурсивно, взяв в качестве
 $lst$ новый список, состоящий из конкатенации только что образoваннoй пары и xвоста $lst$.
 \item Рассматриваем пару, стоящую в голове списка $lst$. Если какой-то элемент пары является
 метапеременной $\xi$, то $\xi\notin Dom(\theta)$ (так как мы провели замену на втором шаге).
 Если пара --- это две метапеременные $\xi_1$ и $\xi_2$, то создаем подстановку
 $\theta':\xi_1 \mapsto \xi_2$. Если пара состоит из метапеременной $\xi$ и терма $t$
 (который не является метапеременной), то в качестве $\theta'$ берем подстановку
 $\xi\mapsto t$. Эта пара не может являться парой функциональных символов, так как этот случай был рассмотрен на шаге 1.
 Если, пара состоит из других термов, не включенных в случаи выше --- унификация невозможна
 (возвращаем NULL).
 В качестве $\Theta$ возьмем композицию $\theta$ и $\theta'$.
 Затем запустим функцию рекурсивно от хвоста списка пар термов, $\Theta$ и $\phi$.
%  \item Если мы унифицируем метапеременную $\xi$ с другим термом $t$,  то проверяем, что
%  $\xi \in Dom(\theta)$. Если это так, то проводим унификацию пары $t$ и $\theta(\xi)$ как на шаге 2.
%  Создаем подстановку $\theta': \xi \mapsto t$ и строим $\Theta$ как композицию $\theta$ и $\theta'$.
%  Затем необходимо запустить функцию
%  рекурсивно  от хвоста списка пер термов, $\Theta$ и $\phi$ (аналогично шагу 2).
%  Иначе унификацию провести невозможно --- возвращаем NULL.
 \item Когда функция примет пустой список формул, то унификация заканчивается. Если подстановка
 $\theta$ удовлетворяет ограничениям, то она возвращается в качестве результата работы функции.
 Иначе возвращается NULL.
\end{enumerate}

\paragraph{}
Это алгоритм проведения унификации для исчисления с обычными плюс-правилами вывода. Алгоритм
для правил с ослабленными ограничениями приводиться не будет, он аналогичен алгоритму для
обычных правил.
\paragraph{}
В случае ослабленных правил проверка ограничений осуществляется с помощью функции
$checkRestrictionsLiberalised$, а в случае обычных --- $checkRestrictionsNormal$ (обе функции описаны
в разделе~\ref{sec:subs_and_forbs}). Для ослабленных ограничений осуществлять композицию подстановок
нет необходимости, провека ограничений будет проходит корректно и в этом случае. Полученная
подстановка не будет удовлетворять определению подстановки без циклов из раздела~\ref{sec:subs_and_forbs},
но будет приводима к такому виду.
% \paragraph{Замечание 1.} При осуществлении композиции подстановок в случае обычных правил
% новая подстановка $\theta'$ (она вводится в пунктах 2 и 3)\footnote{Я думаю, что с помощью подобных
% оговорок я смогу учесть Ваше замечание насчет области видимости обозначений} применяется ко хвосту
% списка пар термов. Это является довольно ресурсоемкой операцией, но она является необходимой
% для данного исчсиления, так как можно подобрать пример для которого унификация
% будет проходить некорректно.\footnote{Вот эти пары формул: $(\mu,f(\nu))$ и $(\nu,g(\mu))$. Никакие
% органичения на метапеременные $\mu$ и $\nu$ не накладываются.} Для исчисления с ослабленными
% правилами вывода этого делать не нужно, так как метод проверки ограничений существенно другой.
% 
% \paragraph{Замечание 2.}
% Проверка ограничений осуществляется с помощью функций $checkRestrictionsNormal$ и
% $checkRestrictionLiberalised$. Её можно вынести из этой функции и вызывать при переборе целей
% %   унификации.
\paragraph{}
Итак, мы рассмотрели основную функцию унификации ---  $unif\!\_pairs\!\_list$. Она является основной,
потому что
запускается чаще всего при осуществлении унификации и большая часть времени работы автопрувера
заключается в ней. Для двух методов поиска вывода в автопрувере написан свой вариант этой функции.

\subsection{Построение дерева поиска вывода с метапеременными}
\label{sec:proveAbstr}
\paragraph{}
Приведенная ниже функция $proveAbstr$ --- основная функция поиска вывода. Она постепенно строит дерево вывода и
проводит унификации. Если унификация успешно завершается, то и поиск вывода
заканчивается успешно.
\\ \quad \\
\textbf{Функция:}
\textit{$prove\!Abstr(seq, plusTerm,minusTerm,makeUni\!f,$\\
            \phantom  \qquad \qquad \qquad \qquad $maxUnifCount)$}\\
\textbf{Вход: } $seq$ --- исходная cеквенция типа $bigSeq$, которую будем доказывать;
$plusT\!erm$ и $minusT\!erm$ --- функции получения нового терма при попытке контрприменить
какое-нибудь правило вывода к секвенции; $makeU\!ni\!f$ --- процедура унификации списка секвенций;
$maxU\!nif\!Count$ --- максимальное количество унификаций по распорядку.\\
\textbf{Выход:} Дерево вывода с метапеременными, результат доказательства.

\paragraph{}
Параметры $plusTerm$ и $minusTerm$ --- это параметры-функции; в качестве них передаются
функции $getMinusTerm$ и $getPlusTerm$ из раздела \ref{sec:subs_and_forbs}.
%\paragraph{}
%
\paragraph{}
Как было сказано в разделе \ref{sec:build_tree}, процедура поиска вывода может заканчиваться с
результатом ``выводима'' или ``неизвестно''. С такими же результатами оканчивает свою работу и функция
$proveAbstr$. Результат ``выводима'' означает, что поиск вывода
закончился успешно (следовательно, формула общезначима).
\paragraph{}
По причине того, что исчисление предикатов алгоритмически не разрешимо, необходимо выбрать условие
для выхода из функции поиска вывода. В данном автопрувере функция $proveAbstr$ заканчивает свою работу
с результатом ``неизвестно'', если унификация по распорядку уже проводилась некоторoе количество
раз. Максимальное количество унификаций по распорядку передается функции $proveAbstr$ в параметре
$maxU\!nif\!Count$. Внутри функции $proveAbstr$ введен счетчик для учета количества унификаций
по распорядку. Таким образом, результат ``неизвестно'' означает,
что поиск вывода не дал конкретного результата: формула может быть является общезначимой, а может
быть и нет.
\paragraph{}
При реализации используется глобальная переменная $leaves$ --- список листовых секвенций.\\
\textbf{Метод:}
\begin{enumerate}
 \item Создаем дерево с одним узлом --- исходной секвенцией. Список $leaves$ содержит
 только один элемент --- только что созданную секвенцию.
 \item Для всех листовых секвенций выполняем следующее:
 \begin{itemize}
  \item Пытаемся осуществить контрприменение какого-либо правила к этой секвенции,
  используя функцию $applyRule$ из раздела~\ref{sec:sequences}.
  \item Если осуществить контрприменение удалось, то убираем эту секвенцию из $leaves$, а добавляем туда
  только что полученные секвенции.
 \end{itemize}
 \item Если ни разу не удалось осуществить контрприменение правила, то проводим
 унификацию по распорядку.  Переходим на шаг 5.
 \item Если удалось осуществить контрприменение
 правил хотя бы один раз, то возвращаемся на шаг 2.
 \item Проводим унификацию, вызывая функцию $makeU\!ni\!f$ от аргумента $leaves$.
 Уменьшаем количество доступных унификаций по распорядку на 1.
 Если унификация прошла успешно, то возвращаем дерево вывода и результат ``доказано''.
 \item Если число доступных унификаций равно 0, то заканчиваем доказательство с результатом
 ``неизвестно''. Иначе для всех листовых секвенций вызываем функцию
$refreshCounters$ из раздела~\ref{sec:sequences} и затем переходим на шаг 2.
\end{enumerate}

\paragraph{Замечаниие.} Для некоторых формул получить вывод можно быстрее, если не дожидаться
проведения унификации по распорядку, а провести унификацию ранее. Такие унификации будем
называть \textit{промежуточными}. В автопрувере промежуточные унификации запускаются после
каждого контрприменения минус-правила. Результаты работы автопрувера с использованием промежуточных унификаций
будут представлены в разделе~\ref{sec:results}.
%  Есть соревнования автопруверов для логики первого порядка. Они юзают библиотеку тестовых
%  формул -  TPTP.

\section{Заключение}
\label{sec:results}
В данной курсовой работы был реализован автопрувер на основе секвенциального исчисления с
ослабленными кванторными правилами, приведенными в~\cite{konev}. Также было проведено сравнение
скорости построения и объёма дерева поиска вывода для автопруверов на основе обычных правил вывода
и ослабленных. При тестировании использовались тесты из статьи~\cite{tests}.
\newcommand{\Title}[1]{\multicolumn{3}{|c|}{#1}}
\begin{center}
\begin{table}
  \centering
   \begin{tabular}{ | c | c | c | c  | c  | c  | c  | c | c | c| c| c |}
    \hline
       & \multicolumn{2}{|c|}{1} & \Title{2} & \Title{3} & \Title{4} \\ \cline{2-12}
    № & время  & n &         время & n&\% &                время &n &\%&                  время &n&\% \\ \hline
18 & 0.55 & 7 & 0.59 & 7 & 7.27\% & 1.34 & 4 & 143.60\% & 2.00 & 4 & 263.60\% \\
19 & 2.60 & 22 & 2.62 & 22 & 0.77\% & 3.27 & 22 & 25.76\% & 26.57 & 22 & 921.90\% \\
20 & 2.50 & 16 & 2.25 & 16 & -10.00\% & 3.00 & 16 & 20.00\% & 5.12 & 16 & 104.80\% \\
21 & 2.33 & 25 & 2.29 & 25 & -1.71\% & 2.83 & 25 & 21.45\% & 22.81 & 25 & 878.90\% \\
22 & 0.70 & 11 & 0.65 & 11 & -7.14\% & 1.75 & 11 & 150.00\% & 3.30 & 11 & 371.40\% \\
23 & 0.61 & 13 & 0.61 & 13 & 0.00\% & 1.71 & 13 & 180.30\% & 3.18 & 13 & 421.30\% \\
24 & 72.60 & 61 & 9.43 & 61 & -87.00\% & 6.27 & 53 & -91.30\% & 60.15 & 53 & -17.10\% \\
30 & 2.11 & 19 & 2.28 & 19 & 8.06\% & 2.73 & 19 & 29.38\% & 11.08 & 19 & 425.10\% \\
31 & 3.44 & 30 & 3.67 & 30 & 6.69\% & 4.44 & 30 & 29.06\% & 23.09 & 30 & 571.20\% \\
32 & 6.20 & 48 & 6.91 & 48 & 11.45\% & 6.82 & 48 & 10.00\% & 51.17 & 48 & 725.30\% \\
33 & 3.49 & 53 & 3.66 & 53 & 4.87\% & 4.16 & 53 & 19.19\% & 10.10 & 53 & 189.30\% \\
35 & 2.22 & 15 & 2.33 & 15 & 4.95\% & 1.50 & 6 & -32.40\% & 2.17 & 6 & -2.25\% \\
36 & 368.41 & 52 & 52.83 & 52 & -85.60\% & 3.71 & 19 & -98.90\% & 13.73 & 19 & -96.20\% \\
37 & 491.79 & 58 & 17.58 & 58 & -96.40\% & 7.49 & 28 & -98.40\% & 18.80 & 28 & -96.10\% \\
38 & 0.47 & 8 & 0.52 & 8 & 10.63\% & 1.74 & 8 & 270.20\% & 3.11 & 8 & 561.70\% \\
41 & 1.80 & 15 & 2.01 & 15 & 11.66\% & 2.44 & 15 & 35.55\% & 9.91 & 15 & 450.50\% \\
42 & 14.58 & 48 & 9.29 & 48 & -36.20\% & 19.62 & 48 & 34.56\% & 94.53 & 48 & 548.30\% \\
50 & 4.66 & 21 & 3.29 & 18 & -29.30\% & 2.33 & 12 & -50.00\% & 12.99 & 12 & 178.70\% \\
57 & 2.23 & 11 & 2.29 & 11 & 2.69\% & 2.67 & 11 & 19.73\% & 10.83 & 11 & 385.60\% \\
62 & 6.31 & 71 & 6.32 & 71 & 0.16\% & 6.40 & 71 & 1.43\% & 54.49 & 71 & 763.50\% \\   \hline
    \end{tabular}
    \caption{}
\end{table} \end{center}
\paragraph{}
В \textit{Таблице 1} приведены точные результаты скорости работы автопрувера при использовании
различных методов:
 \begin{enumerate}
  \item обычные правила без промежуточных унификаций;
  \item обычные правила с промежуточными унификациями;
  \item ослабленные правила без промежуточных унификаций;
  \item ослабленные правила с промежуточными унификациями.
 \end{enumerate}
В левом столбце талицы указаны номера тестов из~\cite{tests}.
Для первого метода в левом столбце указано время работы (в мс, среднее за 10 испытаний), а в
правом --- количество узлов в дереве вывода. Для остальных методов также указано изменение времени
работы в процентах по сравнению с первым методом.
\paragraph{}
Видно, что если правила с ослабленными ограничениями дают выигрыш в количестве узлов, то и работают
быстрее. Промежуточные унификации для обычных правил позволяют улучшить доказательство, но
их использование для ослабленных правил не оправданно: ни на одном тесте не удалось получить
более короткого доказательства.

\section{Приложения}
\subsection{Графическое представление дерева поиска вывода}
\paragraph{}
Автопрувер выдает дерево поиска вывода для  полученной на входе формулы в формате GIF.
Дерево ориентировано корнем вверх и бывает двух типов: подробное и легковесное. Легковестное
содержит в себе только секвенции и последовательность контрприменений правил вывода.
Формат подробного дерева представлен ниже.
\begin{itemize}
 \item Прямоугольник представляет собой узел, содержащий секвенцию. Верхняя половина --- это
вся секвенция. Для наглядности представления дерева антицедент, сукцедент и стрелка располагаются
на различных строках. Однако для больших формул дерево всёравно довольно быстро разростается в ширину.
Нижняя половина представляет собой формулу, к которой контр применялось правило при построении дерева.
\item Эллипс с цифрой внутри, связанный с ровно одним узлом дерева, демонстрирует, что к этому узлу и ко
всем узлам, которые имеют потомком эллипс с той же цифрой, применялась промежуточная унификация
одновременно. К узлам, обведенным большим прямоугольником, унификация применялась по распорядку.
\item Эллипс с подстановками метапеременных в термы может быть соединен только с листами дерева.
Такие узлы могут появиться только при удачном завершении доказательства. Они демонстрируют, какие
термы надо сопоставить метапеременным, чтобы листовые секвенции обратились в аксиомы.
\item Эллипс со словом $axiom$. Листовая секвенция обратилась в аксиому без применения каких-либо подстановок.
\item С корнем дерева может быть связан эллипс с текстом:
  \begin{itemize}
   \item $N\!o\  result$ --- автопрувер произвел несколько унификаций по распорядку, не доказал формулу и закончил
            работу. Возможно, формула верна, но требуется больше унификаций.
   \item $Provable$ --- формула выводима (следовательно, общезначима).
  \end{itemize}
\end{itemize}
% \newpage
% \subsection{Тестирование автопрувера}
% \paragraph{Формат входного файла}
% Это пример одного из входных файлов для автопрувера
% \begin{verbatim}
% -dot on
% -o last_res/t1_18
% -p0 EXZ y (ALL x (F(y) => F(x)))
% -p4 EXZ y (ALL x (F(y) => F(x)))
% \end{verbatim}
% Здесь задействованы следующие параметры:
% \begin{description}
%  \item [-o <префикс>] Установить префикс для имени выходных файлов.
%  \item[-p0 <формула>] Доказать формулу используя классические правила вывода.
%  Файлы результата будут начинаться с указанного префикса с добавлением ``.old''.
%  \item[-p4 <формула>] Доказать формулу используя правила вывода с ослабленными
%  ограничениями. Файлы результата будут начинаться с указанного префикса с добавлением ``.konev''.
%  \item[-dot on]После попытки доказательства по полученному файлу дерева в формате dot будет
%  строиться картинка с деревом. Например, для правил с ослабленными ограничениями файл будет называться
% \texttt{ <prefix>.konev.dot.gif}. Для корректной работы должен быть установлен пакет graphviz
%  и путь к утилите dot должен быть добавлен в переменную PATH.
%  \item[-dot off] Картинка строиться не будет.
%  \item [-dt light] Дерево вывода автопрувер без подробностей.
%  \item[-dt normal] Подробное дерево вывода автопрувера.
%  \item[\#текст] Строки, начинающиеся с $\#$ игнорируются.
%  \end{description}
%  
% \paragraph{Автоматическое тестирование}
% Если уже есть входной файл с синтаксисом, указанным выше, то его можно передать на вход
% автопруверу, например, вот так: \texttt{./murlock < test1.in}. Автопрувер последовательно выполнит
% команды, указанные в файле. Для автоматического тестирования большого количества тестов
% можно использовать скрипт \texttt{cw1/iter.sh}, который протестирует файлы \texttt{*.in}.
% Корректная работа скрипта гарантируется только для входных файлов, прилагающихся к
% автопруверу, а также для файлов имеющих сходный формат имени:
% \texttt{t<номер теста>\_<номер в статье [3]>.in}. Для каждого теста будет выведена строчка
% в формате $T_EX$, удобная для добавления в таблицу. Скрипт не проведет тестирование для
% классического метода и метода Конева самостоятельно, это должно быть явно прописано во
% входном файле.
\subsection{Примеры деревьев вывода}
Приведенный выше формат деревьев вывода хорошо подходит для наглядного изучения
осуществленных контрприменений правил вывода, но для курсововой записки является
слишком громоздким. Поэтому, при построении доказательства формулы автопрувер также
создает доказательство в текстовом формате, которое можно без изменений использовать
в редакторе $T_EX$.
\paragraph{}
Ниже представлен протокол поиска вывода 35-го теста из~\cite{tests} 3-м методом.
\begin{enumerate}
\item $\rightarrow\exists  x ( \exists  y (P(x)  \Rightarrow  ( \forall  x ( \forall  y P(y)))))$\\
 from [2] by rule $\exists \rightarrow $ with new term $\alpha$
\item $\rightarrow\exists x(\exists y(P(x)\Rightarrow(\forall x(\forall y P(y))))),\exists y(P(\alpha)\Rightarrow(\forall x(\forall y P(y))))$\\
 from [3] by rule $\exists \rightarrow $ with new term $\beta$
\item $\rightarrow P(\alpha)\Rightarrow(\forall x(\forall y P(y))),\exists y (P(\alpha)\Rightarrow(\forall x(\forall y P(y)))),$\\$\exists x(\exists y (P(x)\Rightarrow(\forall x(\forall y P(y)))))$\\
 from [4] by rule $\Rightarrow \rightarrow $
\item $P(\alpha)\rightarrow   \forall  x ( \forall  y P(y)),\exists x (\exists y (P(x)\Rightarrow (\forall x (\forall y P(y))))),$\\$\exists y (P(\alpha)\Rightarrow (\forall x (\forall y P(y))))$\\
 from [5] by rule $\forall \rightarrow $ with new term $w3$
\item $P(\alpha)\rightarrow \forall y P(y),\exists y (P(\alpha) \Rightarrow (\forall x (\forall y P(y)))),$\\$\exists x (\exists y (P(x)\Rightarrow(\forall x (\forall y P(y)))))$\\
 from [6] by rule $\forall \rightarrow $ with new term $w4$
\item $P(\alpha)\rightarrow  P(w4),$ $\exists  x (\exists y (P(x)\Rightarrow(\forall x (\forall y P(y))))),$\\$\exists  y (P(\alpha)\Rightarrow  ( \forall  x ( \forall  y P(y))))$\\
 unification succeded using [$\alpha \mapsto w4$]
\end{enumerate}
Ниже представлен протокол поиска вывода 35-го теста из~\cite{tests} 1-м методом.
\begin{enumerate}
\item $ \rightarrow   \exists  x ( \exists  y (P(x)  \Rightarrow  ( \forall  x ( \forall  y P(y)))))$\\
 from [2] by rule $\exists \rightarrow $ with new term $\alpha$
\item $ \rightarrow   \exists  x ( \exists  y (P(x)  \Rightarrow  ( \forall  x ( \forall  y P(y))))),  \exists  y (P(\alpha)  \Rightarrow  ( \forall  x ( \forall  y P(y))))$\\
 from [3] by rule $\exists \rightarrow $ with new term $\beta$
\item $ \rightarrow  P(\alpha)  \Rightarrow  ( \forall  x ( \forall  y P(y))),  \exists  y (P(\alpha)  \Rightarrow  ( \forall  x ( \forall  y P(y)))),$\\$\exists  x ( \exists  y (P(x)  \Rightarrow  ( \forall  x ( \forall  y P(y)))))$\\
 from [4] by rule $ \Rightarrow \rightarrow $
\item $P(\alpha) \rightarrow   \forall  x ( \forall  y P(y)),  \exists  x ( \exists  y (P(x)  \Rightarrow  ( \forall  x ( \forall  y P(y))))),$\\$\exists  y (P(\alpha)  \Rightarrow  ( \forall  x ( \forall  y P(y))))$\\
 from [5] by rule $\forall \rightarrow $ with new term $w1$
\item $P(\alpha) \rightarrow   \forall  y P(y),  \exists  y (P(\alpha)  \Rightarrow  ( \forall  x ( \forall  y P(y)))),$\\$\exists  x ( \exists  y (P(x)  \Rightarrow  ( \forall  x ( \forall  y P(y)))))$\\
 from [6] by rule $\forall \rightarrow $ with new term $w2$
\item $P(\alpha) \rightarrow  P(w2),  \exists  x ( \exists  y (P(x)  \Rightarrow  ( \forall  x ( \forall  y P(y))))),$\\$\exists  y (P(\alpha)  \Rightarrow  ( \forall  x ( \forall  y P(y))))$\\
 from [7] by rule $\exists \rightarrow $ with new term $\gamma$
\item $P(\alpha) \rightarrow  P(w2),  \exists  y (P(\alpha)  \Rightarrow  ( \forall  x ( \forall  y P(y)))),$\\$\exists  x ( \exists  y (P(x)  \Rightarrow  ( \forall  x ( \forall  y P(y))))),  \exists  y (P(\gamma)  \Rightarrow  ( \forall  x ( \forall  y P(y))))$\\
  used in temporary unifications: [4]\\
 from [8] by rule $\exists \rightarrow $ with new term $\delta$
\item $P(\alpha) \rightarrow  P(w2), P(\alpha)  \Rightarrow  ( \forall  x ( \forall  y P(y))),\exists  y (P(\gamma)  \Rightarrow  ( \forall  x ( \forall  y P(y)))),$\\$\exists  x ( \exists  y (P(x)  \Rightarrow  ( \forall  x ( \forall  y P(y))))),  \exists  y (P(\alpha)  \Rightarrow  ( \forall  x ( \forall  y P(y))))$\\
  used in temporary unifications: [5]\\
 from [9] by rule $ \Rightarrow \rightarrow $
\item $P(\alpha) \rightarrow  P(w2),  \forall  x ( \forall  y P(y)),  \exists  y (P(\alpha)  \Rightarrow  ( \forall  x ( \forall  y P(y)))),$\\$  \exists  x ( \exists  y (P(x)  \Rightarrow  ( \forall  x ( \forall  y P(y))))),  \exists  y (P(\gamma)  \Rightarrow  ( \forall  x ( \forall  y P(y))))$\\
 from [10] by rule $\forall \rightarrow $ with new term $w3$
\item $P(\alpha) \rightarrow  P(w2),  \forall  y P(y),  \exists  y (P(\gamma)  \Rightarrow  ( \forall  x ( \forall  y P(y)))),$\\$  \exists  x ( \exists  y (P(x)  \Rightarrow  ( \forall  x ( \forall  y P(y))))),  \exists  y (P(\alpha)  \Rightarrow  ( \forall  x ( \forall  y P(y))))$\\
 from [11] by rule $\forall \rightarrow $ with new term $w4$
\item $P(\alpha) \rightarrow  P(w4), P(w2),  \exists  y (P(\alpha)  \Rightarrow  ( \forall  x ( \forall  y P(y)))),$\\$  \exists  x ( \exists  y (P(x)  \Rightarrow  ( \forall  x ( \forall  y P(y))))),  \exists  y (P(\gamma)  \Rightarrow  ( \forall  x ( \forall  y P(y))))$\\
 from [12] by rule $\exists \rightarrow $ with new term $\varepsilon$
\item $P(\alpha) \rightarrow  P(w2), P(w4), P(\gamma)  \Rightarrow  ( \forall  x ( \forall  y P(y))),$\\$  \exists  y (P(\gamma)  \Rightarrow  ( \forall  x ( \forall  y P(y)))),  \exists  x ( \exists  y (P(x)  \Rightarrow  ( \forall  x ( \forall  y P(y))))),$\\$\exists  y (P(\alpha)  \Rightarrow  ( \forall  x ( \forall  y P(y))))$\\
  used in temporary unifications: [6]\\
 from [13] by rule $\Rightarrow \rightarrow$
\item $P(\gamma),P(\alpha)\rightarrow P(w4), P(w2),\forall x(\forall y P(y)),$\\$\exists y (P(\alpha)\Rightarrow(\forall x (\forall y P(y)))),\exists  x (\exists y (P(x)\Rightarrow(\forall  x (\forall  y P(y))))),$\\$\exists  y (P(\gamma) \Rightarrow (\forall x (\forall y P(y))))$\\
 from [14] by rule $\forall \rightarrow $ with new term $w5$
\item $P(\alpha), P(\gamma) \rightarrow  P(w2), P(w4),  \forall y P(y),\exists y (P(\gamma) \Rightarrow (\forall  x (\forall y P(y)))),$\\$\exists x (\exists y (P(x)\Rightarrow(\forall  x (\forall y P(y))))), \exists  y (P(\alpha)  \Rightarrow  ( \forall  x ( \forall  y P(y))))$\\
 from [15] by rule $\forall \rightarrow $ with new term $w6$
\item $P(\gamma), P(\alpha) \rightarrow  P(w6), P(w4), P(w2),  \exists  y (P(\alpha)\Rightarrow (\forall  x (\forall  y P(y)))),$\\$\exists  x ( \exists  y (P(x)  \Rightarrow  ( \forall  x ( \forall  y P(y))))),  \exists  y (P(\gamma)  \Rightarrow  ( \forall  x ( \forall  y P(y))))$\\
 unification succeded using [$\gamma \mapsto w2$]
\end{enumerate}

\newpage
\section{Литература}
\begin{thebibliography}{9}
        \bibitem{hahnle}
        Hahnle R., Schmitt P.H. \textit{The liberalized $\delta$-rule in free variable semantic tableaux} //
        Journal of Automated Reasoning. 1986, Pp. 3-4.
        \bibitem{OCamlManual}
        Leroy X., Doligez D., Frisch A., Garrigue J., Rémy D.,  Vouillon J.
        \textit{The Objective Caml system release 3.12}, 2010, \textit{http://caml.inria.fr/pub/docs/manual-ocaml/index.html}
        \bibitem{tests}
        Pelletier F.J. \textit{Seventy-Five Problems for Testing Automatic Theorem Provers} //
        Journal of Automated Reasoning, No. 2, 1986, Pр. 191-216.
        \bibitem{gerasimov}
        Герасимов А.С. \textit{Курс математической логики и теории вычислимости.}
        СПб.: Издательство ``ЛЕМА``, 2009.
        \bibitem{FuncDT}
        Кирпичёв Е. \textit{Элементы функциональных языков.} // Журнал ``Практика функционального
        программирования'', выпуск 3, 2009 г.
        
        \bibitem{klini}
        Клини С.К. \textit{Математическая логика.} М.: Мир, 1973.
        
        \bibitem{konev}
          Конев Б., Жебелиан Т.
          \textit{Метод подъема решений для работы с метапеременными в системе} Т$\exists$ОРЕM$\forall$ //
          Записки научных семинаров Мат. ин-та им. Стеклова, Т. 293, 2002, с. 94-117.


\end{thebibliography}

\end{document}
